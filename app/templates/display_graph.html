<head>
  <style> body { margin: 0; }
  .vertical-menu {
    width: 300px; /* Set a width if you like */
  }
  .vertical-menu a {
    background-color: #eee; /* Grey background color */
    color: black; /* Black text color */
    display: block; /* Make the links appear below each other */
    padding: 12px; /* Add some padding */
    text-decoration: none; /* Remove underline from links */
  }
  .vertical-menu a:hover {
    background-color: #ccc; /* Dark grey background on mouse-over */
  }
  </style>

  <script src="//unpkg.com/three"></script>
  <script src="//unpkg.com/three-spritetext"></script>
  <script src="//unpkg.com/3d-force-graph"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
  <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
</head>

<body>

    <div id="3d-graph">
    </div>
    <div id="menu" class="vertical-menu" style="position: absolute; top: 5px; left: 5px; display: none">
      <a id="showLinks"> Show Connected Articles </a>
      <a id="expand"> Expand Network Using Article </a>
      <a id="open"> Open Article in New Tab </a>
      <a id="closeMenu"> Close Menu </a>
    </div>

  <script>
    const elem = document.getElementById('3d-graph');



    // Graph data generated in python
    var g_data = {{ force_g_data | tojson | safe }};
    g_data = JSON.parse(g_data);

    // Add neighbor attribute to each node
    createNeighbors(g_data);


    // Initialize Global Variables
    const home_url = 'https://en.wikipedia.org/wiki/';

    const highlightNodes_from_node = new Set();
    const highlightLinks_from_node = new Set();
    const highlightNodes_from_link = new Set();
    const highlightLinks_from_link = new Set();
    const bridge_nodes = new Set();
    let leftClickNode = null;

    // Center of gravity of all the node weighted equally
    var centerGravity = new THREE.Vector3(0, 0, 0);

    // Check if control key is pressed up or down
    $(document).keydown(function(event) {
      // console.log(event.which);
      if (event.which === 17 || event.which === 91)
          cntrlIsPressed = true;
      if (event.which === 16)
          shftIsPressed = true;
      });

    $(document).keyup(function() {
        cntrlIsPressed = false;
        shftIsPressed = false;
    });

    // Toggle global variable initialization
    var cntrlIsPressed = false;
    var shftIsPressed = false;
    var rightClickedNode = null;

    /*
    Below we define the graph using the https://github.com/vasturiano/3d-force-graph,
    a library created by Vasco Asturiano
    */
    const Graph = ForceGraph3D({controlType: 'fly'})
      (elem)
        .graphData(g_data)
        .enableNodeDrag(false)
        .nodeLabel('id')
        .nodeColor(node => highlightNodes_from_link.has(node) ||  highlightNodes_from_node.has(node) ?
                node === leftClickNode ? 'rgb(255,0,0,1)' : 'rgba(255,0,0,1)' : node.color)
        .linkWidth(link => highlightLinks_from_node.has(link) || highlightLinks_from_link.has(link) ? 2 : .001)
        .linkVisibility(link => highlightLinks_from_node.has(link) || highlightLinks_from_link.has(link))
        .linkDirectionalParticles(link => highlightLinks_from_link.has(link) || highlightLinks_from_node.has(link) ? 1.5 : 0)
        .linkDirectionalParticleWidth(4)
        .nodeThreeObjectExtend(true)
        .nodeThreeObject(node => {
          // load image and node sphere
              const obj = new THREE.Mesh();
              var sprite = new SpriteText(node.title);
              sprite.color = node.color;
              sprite.center.set(.5, -.8);
              obj.add(sprite);

              const area_thresh = 18e6;

              if (node.pageimage.source && node.pageimage.width * node.pageimage.height < area_thresh) {
                const imgTexture = new THREE.TextureLoader().load(node.pageimage.source);
                const material = new THREE.SpriteMaterial({map: imgTexture});
                sprite = new THREE.Sprite(material);
                var new_h = 40;
                var new_w = node.pageimage.width / node.pageimage.height * new_h;
                sprite.scale.set(new_w, new_h);
                sprite.center.set(.5, 1.2);
                obj.add(sprite);
              }
              return obj})
        .nodeLabel(node => label(node))
        .onNodeRightClick(node => {
          displayMenu(node);
        })
        .onBackgroundRightClick(() => {
          undisplayMenu();
        })
        .onBackgroundClick(() => {
          undisplayMenu();
        })
        .onNodeClick(node => {
          // heighlight all the adjacent nodes and vertices
          undisplayMenu();
          look_at(node);
          highlightNodes_from_node.clear();
          highlightLinks_from_node.clear();
          if ((!node && !highlightNodes.size) || (node && leftClickNode === node) || !shftIsPressed) {
            leftClickNode = null;
            updateHighlight();
          }

          if (cntrlIsPressed) {
            window.open(home_url + node.title, "_blank");
          } else if (shftIsPressed) {
            if (node) {
              highlightNodes_from_node.add(node);
              node.neighbors.forEach(neighbor => highlightNodes_from_node.add(neighbor));
              node.links.forEach(link => highlightLinks_from_node.add(link));
            }

            leftClickNode = node || null;

            updateHighlight();
          }
        });


    // Spread nodes a little wider
    Graph.d3Force('charge').strength(-1050);
    Graph.d3Force('link').distance(750);
    Graph.d3Force('link').strength(link => bridge_nodes.has(link.source) || bridge_nodes.has(link.target) ? .99 : .8);

    // console.log(Graph);
    setTimeout(() => look_at(g_data.nodes[0]), 8000);

    setTimeout(() => fixAllNodes(), 9e3);



    /*
    In this part of the code, we deal with custom context menu, which pops up during
    right click. We can show the nodes links, expand the graph using the node as a
    seed, or open the article associated with node in a new tab
     */

    document.getElementById('showLinks').addEventListener('click', event => {
      showConnections(rightClickedNode);
    });

    document.getElementById('expand').addEventListener('click', event => {
      loadExtendedGraph(rightClickedNode);
    });

    document.getElementById('open').addEventListener('click', event => {
      openNodeUrl(rightClickedNode);
    });

    document.getElementById('closeMenu').addEventListener('click', event => {
      undisplayMenu();
    });

    function displayMenu(node) {
      // Opens context menu next to node
      document.getElementById("menu").style.display = "block";
      var coords = Graph.graph2ScreenCoords(node.x, node.y, node.z);
      document.getElementById("menu").style.top = coords.y.toString() + "px";
      document.getElementById("menu").style.left = (coords.x + 30).toString() + "px";
      rightClickedNode = node;
    }

    function undisplayMenu() {
      // Close context menu and sets right clicked node to null
      document.getElementById("menu").style.display = "none";
      rightClickedNode = null;
    }

    /*
    End context menu code
     */

    function showConnections(node) {
      // Shows the links between nodes
      highlightNodes_from_node.clear();
      highlightLinks_from_node.clear();
      if (node) {
        highlightNodes_from_node.add(node);
        node.neighbors.forEach(neighbor => highlightNodes_from_node.add(neighbor));
        node.links.forEach(link => highlightLinks_from_node.add(link));
      }

      leftClickNode = node || null;

      updateHighlight();
    }

    function openNodeUrl(node) {
      window.open(home_url + node.title, "_blank");
    }

    function createNeighbors(json_data) {
      // Add neighbors attribute for node with adjacent nodes
      const seed_id = json_data.nodes[0].id;
      let offset = json_data.nodes[1].id - 1;
      console.log('offset');
      console.log(offset);
      json_data.links.forEach(link => {
        const a = link.source === seed_id ? json_data.nodes[0] : json_data.nodes[link.source - offset];
        const b = link.target === seed_id ? json_data.nodes[0] : json_data.nodes[link.target - offset];
        !a.neighbors && (a.neighbors = []);
        !b.neighbors && (b.neighbors = []);
        a.neighbors.push(b);
        b.neighbors.push(a);

        !a.links && (a.links = []);
        !b.links && (b.links = []);
        a.links.push(link);
        b.links.push(link);
      });
    }
    function  fixAllNodes() {
      g_data.nodes.forEach(node => {
        fixLocation(node);
      })
    }

    function fixLocation(node) {
        node.fx = node.x;
        node.fy = node.y;
        node.fz = node.z;
    }

    function updateHighlight() {
      // color vertices and node
      Graph
        .nodeColor(Graph.nodeColor())
        .linkWidth(Graph.linkWidth())
        .linkDirectionalParticles(Graph.linkDirectionalParticles());

    }


    function label(node) {
      // display iframe previewing article as label
          var w = 900;
          var h = 700;
          var url = home_url + node.title;
          return '<iframe style="visibility:hidden;" onload="this.style.visibility = \'visible\';" src="' +
                  url + '" width="' + w + '" height="' + h + '">';
    }

    function look_at(node) {
      // moves close to the node without rotating the camera
      const distance = 300;
      const delay = 500;
      const cp = Graph.cameraPosition();
      let vec = new THREE.Vector3(cp.x - node.x, cp.y - node.y, cp.z - node.z);
      vec = vec.normalize();
      vec = vec.multiplyScalar(distance);
      Graph.cameraPosition({ x: vec.x + node.x, y: vec.y + node.y, z: vec.z + node.z},
                            node, delay);
    }

    function loadExtendedGraph(node) {
      let load_graph_url = '{{url_for("load_graph")}}';
      console.log(load_graph_url);
      load_graph_url = load_graph_url.concat('?url=', node.title);
      load_graph_url = load_graph_url.concat('&start_id=', g_data.nodes.length);
      load_graph_url = load_graph_url.concat('&return_data=', '1');
      load_graph_url = load_graph_url.concat('&seed_id=', node.id);

      $.getJSON(load_graph_url, function(data) {
        let status_url = '{{url_for("job_status")}}';
        status_url = status_url.concat('?job_id=', data.job_id);
        load_graph_in_backround_then_merge(status_url, node, data.job_id);

      })
    }

    function load_graph_in_backround_then_merge(status_url, node, job_id) {
      //
      $.getJSON(status_url, function(data) {
        switch (data.status) {
          case "unknown":
              console.log("Unknown job id", "danger");
              break;
          case "finished":
              console.log("success");
              let graph_data_url = '{{url_for("make_graph")}}'; // '/make_graph?url='.concat(url_str, '&job_id=', job_id);
              graph_data_url = graph_data_url.concat('?url=', node.title);
              graph_data_url = graph_data_url.concat('&job_id=', job_id);
              graph_data_url = graph_data_url.concat('&return_data=', '1');
              merge_graph(graph_data_url, node);
              break;
          case "failed":
              console.log("Job failed: " + data.message, "danger");
              break;
          default:
            console.log(data.progress);
            setTimeout(function() {
              load_graph_in_backround_then_merge(status_url, node, job_id);
            }, 500);
        }
      });
    }

    function merge_graph(graph_data_url, node) {
      // merges graph data from graph_data_url with current graph usine "node" as the bridge connection
      $.getJSON(graph_data_url, function (data) {
        createNeighbors(data);
        // setLocationsToNode(data, node);
        node.neighbors = node.neighbors.concat(data.nodes[0].neighbors);
        node.links = node.links.concat(data.nodes[0].links);
        bridge_nodes.add(node);
        fixLocation(node);
        g_data.nodes = g_data.nodes.concat(data.nodes.slice(1));
        g_data.links = g_data.links.concat(data.links);
        reCenterGraph(node);
        Graph.graphData(g_data);
      });
      setTimeout(() => fixAllNodes(), 9e3);

    }

    function reCenterGraph(seed_node) {
      // sets location of all data nodes to the location of seed_node and set start velocity away from graph senter
      let offset = (new THREE.Vector3(seed_node.x, seed_node.y, seed_node.z)).sub(centerGravity);
      offset = offset.multiplyScalar(.2);
      centerGravity = centerGravity + offset;
      Graph.d3Force('center').x(centerGravity.x);
      Graph.d3Force('center').y(centerGravity.y);
      Graph.d3Force('center').z(centerGravity.z);

    }
  </script>
</body>